\documentclass[UTF8, twoside]{EPURapport}
\input{include.tex}

\thedocument{Pattern recognition project draft}{Multi-scale graph comparison}{Multi-scale graph comparison}

\grade{Computer Aided Decision Support\\ International Research Master 2\\ 2013 - 2014}

\authors{%
	\category{Student}{%
		\name{Thomas NOGUER} \mail{thomas.noguer@etu.univ-tours.fr}
	}
	\details{M2RI CADS 2013 - 2014}
}

\supervisors{%
	\category{Supervisors}{%
		\name{Romain RAVEREAUX} \mail{romain.raveaux@univ-tours.fr}
	}
	\details{Université François-Rabelais, Tours}
}

\abstracts{abstract}
{keywords}

\begin{document}

\chapter{Formalization of the problem}

	\hspace{4ex}When we wish to do the comparison of two graphs, we can come to a limitation when handling high sized graphs. The community detection algorithms allow to simplify a graph by finding communities of highly related nodes. It is then legitimate to want to use such algorithm to reduce the size of graphs in order to perform calculations that are greedy for computation time.
	
	For this project we choose to use a community detection algorithm for graph comparison. The Louvain's method is very fast and easy to implement. The graph edit distance method is known to be very slow when dealing with high scaled graphs. In this project we want to use the community detection to simplify the graphs to be used in the graph edit distance so we can still compare them with a good computation time.
	
	There is still an issue to solve, how do we use one method with the other. The Louvain's method can be used in several iterations to make the graph more and more simple. We must find a relation between the edit distance between two graphs at different scales and the edit distance between the unchanged graphs. At which scale do we decide that the edit distance is close enough to our original graph? Can we use the different scales together in order to be closer to the distance between the origal graphs? These questions are at the center of our problem.
	
\chapter{Graph Edit Distance}

	\hspace{4ex}We use the following algorithm in order to find the edit distance between two graphs $G1$ and $G2$:
	
\begin{algorithm}
  \caption{Graph Edit Distance}
  \begin{algorithmic}[1]
      \Repeat
      	\For{each node $n \in G1$}
		  \State Add every possible transformation $n$ into the search tree.
		  \State Select a path using $A^*$ and heuristics.
		\EndFor
		\For{each remaining node $n$ of $G2$}
		  \State Add every needed insertion of existing node into the search tree.
		  \State Select a path using $A^*$ and heuristics.
		\EndFor
	  \Until{The path is complete}
	  \State \Return The cost of the found path.
  \end{algorithmic}
\end{algorithm}

\chapter{Community detection: Louvain's method}

	\hspace{4ex}This method is based on two formulas: the modularity $Q$ and the composite modularity gain $\Delta Q$. The modularity of a graph is found following this formula:
\\

\[
Q = \frac{1}{2m}\underset{i,j}{\sum}\left[A_{ij} - \frac{k_ik_j}{2m}\right] \delta(c_i,c_j),
\]

	Where $m$ is the sum of the weights of all the links in the graph ($m = \frac{1}{2}\underset{ij}{\sum}A_{ij}$), $A_{ij}$ the weight of the edge between $i$ and $j$, $k_i$ is the sum of the weights of the edges attached to vertex $i$, $c_i$ is the community to which vertex $i$ is assigned and finally $\delta$ is a function where $\delta(u,v)$ is 1 if $u=v$ and 0 otherwise.
\\
	
	The gain in modularity from moving a node $i$ into a community $C$ is defined by the following formula:
\\

\[
\Delta Q = \left[ \frac{\sum_{in}+k_{i,in}}{2m} - \left( \frac{\sum_{tot}+k_i}{2m} \right)^2 \right] -  \left[ \frac{\sum_{in}}{2m} - \left( \frac{\sum_{tot}}{2m} \right)^2 - \left( \frac{k_i}{2m} \right)^2 \right]
\]

	Where $\sum_{in}$ is the sum of the weights of the links inside the community $C$, $\sum_{tot}$ is the sum of the weights of the links incident to nodes in C and $k_{i,in}$ is the sum of the weights of the links from $i$ to nodes in $C$.
\\

	We use the following algorithm in order to find the communities of our graphs:


\begin{algorithm}
  \caption{Louvain's method}
  \begin{algorithmic}[1]
      \State Assign each node to a unique community.
      \State Compute the initial modularity.
      \Repeat
      	\For{$i \in V$}
		  \For{$j \in V$}
		  	\State Remove $i$ from its community and place it into $j$'s.
		  	\State Compute the composite modularity gain $\Delta Q$.
		  \EndFor
		  \If{There exists a positive gain}
		  	\State Choose $j$ with the maximum gain and truly move $i$ to $j$'s community.
		  \Else
		  	\State $i$ stays in its community.
		  \EndIf
		\EndFor
	  \Until{No further improvement in modularity}
  \end{algorithmic}
\end{algorithm}

\chapter{Multi-scale graph comparision}
	
	\hspace{4ex}We want to compare two graphs G1 and G2. We first use the Louvain's method on G1 until the graph isn't simplified (it is a unique node), we have stored the communities at each scale of the nodes. We then apply the GED algorithm between the most simplified version of G1 and G2, only when we will evaluate the cost of deletion/substitution of a community (i.e. a node that isn't a node in the original graph G1) we will use the GED of the subgraph of this community and G2.
	
	In other words, the algorithm will compare every community (which are sub-graphs) with G2. We hope that this approach will reduce the computation time of the total distance. 
\\

	The algorithm is the same as the Graph Edit Distance, this only difference is the cost function which is $GED(GetSubGraph(c),G2)$ where $c$ is a community and the function $GetSubGraph(c)$ returns the sub-graph of the community c. 
	
\end{document}
