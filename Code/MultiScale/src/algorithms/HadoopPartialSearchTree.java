package algorithms;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.StringTokenizer;
import java.util.UUID;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.Reducer.Context;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.NLineInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.ToolRunner;



import util.CoilCostFunction;
import util.Edge;
import util.EditPath;
import util.ExampleBaseJob;
import util.Graph;
import util.GraphComponent;
import util.ICostFunction;
import util.LetterCostFunction;
import util.MoleculesCostFunction;
import util.MutagenCostFunction;
import util.Node;
import util.UniversalCostFunction;
import util.UniversalEdgeHandler;
import util.ExampleBaseJob;
import util.WebCostFunction;
import xml.XMLParser;



	/**
	 * @author Zeina Abu-Aisheh
	 * 
	 * @param args
	 * 
	 * HadoopPathsCostCalculations is a  class that performs calculations in Hadoop, 
	 * it searches for an optimal solution starting from some generated edit paths (i.e. editPaths that were generated by PartialSearchTree)
	 * 
	 * The type parameters are the type of the input key, the type of the input
	 * values, the type of the output key and the type of the output values
	 * 
	 **/

public class HadoopPartialSearchTree extends ExampleBaseJob{



	 
		/**
		* Mapper class
		* 
		* Input format :trainingGraphId-testGraphId<tab>editPath.toString() 
		* Output format :trainingGraphId-testGraphId<tab> branchOptimalCost
		* 
		* 
		**/

	
		public static class PathCostMapper extends
		Mapper<LongWritable, Text, Text, Text> {


			
			@Override
			/**
			* Mapper class
			* @param key: file's line number 
			* @param Value <trainingGraphFileId-trainingGraphId<tab>toString(editPath)>
			* @param Context is used to emit <key,value> where key = trainingGraphId-testGraphId and value=optimalCost of the branch
			**/
			public void map(LongWritable key, Text value, Context context)
					throws IOException, InterruptedException {

				boolean debug=false;
				double optimalCost=Double.MAX_VALUE;
				
				int methodNumber =0;			
				int dataSetNumber = 0;
				String testGraphFileName="";
			    String trainingGraphFileName=""; // training's file name.
				String trainingGraphClass=""; //training graph's class
				String testGraphClass=""; //test- graph's class
				double alpha=-1;
				double edgeCosts=-1;
				double nodeCosts=-1;
			    				
				// Tokenizing each line of the input file ..
    			StringTokenizer itr = new StringTokenizer(value.toString());
    			Configuration conf = new Configuration();
    			FileSystem fs = FileSystem.get(conf);
    			
                dataSetNumber = Integer.parseInt(itr.nextToken()); // 1st Token: dataSetNumber
                methodNumber = Integer.parseInt(itr.nextToken()); // 2nd Token: methodNumber
                
                	//*************************************************************************************************************************************************
    			testGraphClass = itr.nextToken(); // 3rd Token = testGraphClass
    			if (debug==true) System.out.println("testGraphClass-----------"+testGraphClass);
    			trainingGraphClass = itr.nextToken(); // 4th token = trainingGraphClass
    			if (debug==true) System.out.println("trainingGraphClass-----------"+trainingGraphClass);
    				
    			String editPathString =""; // to get the edit path string
    			
    			double upperBound;

    				//Constants.costFunction = (ICostFunction)new UniversalCostFunction(0.5); 
    			
    			if(dataSetNumber ==1)
				{
					// Letter-MED
					nodeCosts=0.7;
					edgeCosts=1.9;
					alpha=0.75;
					
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

				}
				else if( dataSetNumber == 2)
				{
					// Letter-LOW
					
					nodeCosts=0.3;
					edgeCosts=0.1;
					alpha=0.3;
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
				}
				else if( dataSetNumber == 3)
				{
					// Letter-HIGH
					nodeCosts=0.9;
					edgeCosts=1.7;
					alpha=0.75;
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
				//	path="/usr/local/Letter/HIGH/";	
					}
				else if( dataSetNumber == 4)
				{
					//GREC-CostFunction
					nodeCosts=90;
					edgeCosts=15;
					alpha=0.50;
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
				//	path="/usr/local/IAM/GREC/";
				}
				else if(dataSetNumber == 5 || dataSetNumber ==6)
				{
					//COIL-DEL 	and COIL-RAG
					nodeCosts=2.0;
					edgeCosts=2.0;
					alpha=0.50;
					Constants.costFunction = new CoilCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

				}
				else if (dataSetNumber == 7) 
				{
					// AIDS
					//MoleculesCostFunction
					// 
					nodeCosts=1.1;
					edgeCosts=0.1;
					alpha=0.25;
					
					Constants.costFunction = new MoleculesCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

				//	path="/usr/local/IAM/AIDS/";
					
				}
				else if (dataSetNumber == 8) 
				{
					// FingerPrint
					nodeCosts=0.7;
					edgeCosts=0.5;
					alpha=0.75;
					
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

					//path="/usr/local/IAM/Fingerprint/";
					
				}
				else if (dataSetNumber == 9) 
				{
					//MutagenCostFunction
					// Letter-MED
					nodeCosts=0.11;
					edgeCosts=1.1;
					alpha=0.25;
					
					Constants.costFunction = new MutagenCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

					
				}
				else if (dataSetNumber == 10) 
				{
					//WebCostFunction
				//	path = "/usr/local/IAM";
					
					// no  parameters to set .......
					
					Constants.costFunction = new WebCostFunction();
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					
				}
				else if (dataSetNumber == 11 || dataSetNumber == 12 || dataSetNumber == 13 || dataSetNumber == 14 ||dataSetNumber == 15 || dataSetNumber == 16 || dataSetNumber == 17 || dataSetNumber == 18 || dataSetNumber == 19 || dataSetNumber == 20) 
				{
					nodeCosts=1;
					edgeCosts=1;
					alpha=1;
					
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					
				}
				else 
				{
				
				}

				
				EditPath ed1;
				
				// Tokenizing trainingGraphId-testGraphId<tab>editPath.toString() 
				//String[] itr1 = value.toString().split("");
				//editPathString = itr1[0];
				//int jobNo = Integer.parseInt(itr.nextToken()); // 5th token = JobNo
				//int round = Integer.parseInt(itr.nextToken()); // 6th token = round (i.e. iteration "i")
				editPathString = itr.nextToken(); // 7th token = editPath.toString()
				
				upperBound = Double.parseDouble(itr.nextToken()); // 7th token = upperBound (i.e. editPath.totalCost)
			//	if (debug==true) System.out.print("**************editPathString"+editPathString);
				//= itr1[1];
				
				//parsing the edit Path string
				ed1= new EditPath(editPathString);
				
				testGraphFileName= ed1.getSource().getId();
				trainingGraphFileName = ed1.getTarget().getId();
				
				// Calling the constructor: partialSearchTree(editPath, ..... )
				PartialSearchTree DGED = new PartialSearchTree(ed1,Constants.costFunction,Constants.edgeHandler,false, context, upperBound);
									
		//		System.out.println("BACK FROM PPT "+DGED.OPEN.size() + " localEditPath "+DGED.foundLocalEditPath);
				
			/////////////////////////////////////////////////////////////////////////////////

				

				String toReducer="";
				// if a local editPath is found..
				if(DGED.foundLocalEditPath==true)
				{
					System.out.println("LocalEditPath..."+DGED.NoOfDiscardedEditPaths);
					System.out.println("write+1");
			//		System.out.println("***********Case ---1");

					// there is a local optimal solution ....
					

					toReducer = dataSetNumber+"\t"+methodNumber+"\t"+testGraphClass+"\t"+trainingGraphClass+"\t"+DGED.upperBound+"\t"+ed1.getSource().getId()+"\t"+ed1.getTarget().getId();
					
					
					///////////////////////////////////////////////////////////////////////////////////////////////////
					Path path1 = new Path("/home/hduser/data/tempLocalOptimalSolutions/"+ed1.getSource().getId()+"-"+ed1.getTarget().getId()+"/"+UUID.randomUUID()+".txt");
					FSDataOutputStream out;
					
					out = fs.create(path1);				
					out.writeBytes(toReducer);
					out.writeBytes("\n");
					out.close();
					
					
					/////////////////////////////////////////////////////////////////////////////////////////////////////
					
					context.write(new Text("tempLocalOptimalSolutions"), new Text(""));
					
					
				}
				else
				{ // if the execution was stopped (i.e. out-of-memory case)
				//	System.out.println("***********Case ---2");
					System.out.println("MAP1..."+DGED.NoOfDiscardedEditPaths);
				//	int OutputJobNo = jobNo+1;
    			//	if (debug==true) System.out.println("jobNo"+OutputJobNo);
					
    				System.out.println("DGED length ..."+DGED.OPEN.size());
			        for(int i=0;i<DGED.OPEN.size();i++){
			        	
					    context.progress();
					  //  System.out.println("progressing....");
			        	EditPath pp = DGED.OPEN.get(i);
						String st = pp.toString();
						toReducer = dataSetNumber+"\t"+methodNumber+"\t"+testGraphClass+"\t"+trainingGraphClass+"\t"+st+"\t"+pp.getTotalCosts()+"\t"+upperBound;
						context.write(new Text(pp.getSource().getId()+"-"+pp.getTarget().getId()), new Text(toReducer));
						
						
					}
					
				}
    						
				//    if(debug==true)System.out.println("Before sending data to the reduce phase ..........");
    		
			}
		}

	/**
	* Reducer class
	* 
	* Input format :<testGraphFilePath, trainingGraphFileName-trainingGraphClass-distanceGED(testGraph,trainingGraph> 
	* Output format :<testGraphFilePath: recommended class>
	* 
	* 
	**/
		public static class PathCostReducer extends
			Reducer<Text, Text, Text, Text> {
		
		
		/**
		 * @param key = <sourceTargetIDS>
		 * @param value=<OptimalCost>
		 * **/

		private Path tempLocalOptimalPaths;
		private String tempEditPath;
		private FileStatus[] folderStatus;
		private double currentUpperBound;
		private Path graphPath;
		private String[] parts;
		private FileSystem fs;
		
		public void reduce(Text key, Iterable<Text> values, Context context
		
		) throws IOException, InterruptedException {

			
			Configuration conf = new Configuration();
			fs = FileSystem.get(conf);
			
			tempEditPath="";
			currentUpperBound=-1.0 ;
			
			///////////////////////////////////////////////////////////////////////////////////////////
			
			System.out.println("Reduce .......");

			//**********1st key*****************************************************************************************
		    if(key.toString().equals("tempLocalOptimalSolutions")==true)
		    {	
				// read the files of the directory ./data/tempLocalOptimalSolutions
		    	tempLocalOptimalPaths = new Path("/home/hduser/data/tempLocalOptimalSolutions");
				folderStatus= fs.listStatus(tempLocalOptimalPaths);  // you need to pass in your hdfs path
			
				System.out.println("PATH1::::::"+"/home/hduser/data/tempLocalOptimalSolutions");

		    	SearchAndSaveOptimalSolution();
	
		    }
		    
		    //**********2nd key**********************************************************************************************************************************************
		    else if(key.toString().equals("tempLocalOptimalSolutions")==false)
		    {
		    	
		    	tempLocalOptimalPaths = new Path("/home/hduser/data/tempLocalOptimalSolutions/"+key.toString());
		    	tempEditPath="";
		     	
		    	System.out.println("PATH2::::::"+"/home/hduser/data/tempLocalOptimalSolutions/"+key.toString());
		    	
		    	folderStatus = fs.listStatus(tempLocalOptimalPaths); 
		    	// if the folder ./data/tempLocalOptimalSolutions/G1-G2 is not empty
		    	if(folderStatus!=null)
                {
                 	tempEditPath = SearchMinimumEditPath(folderStatus,fs); // read
                   	graphPath = new Path("/home/hduser/data/LocalOptimalSolutions/"+key.toString()+".txt");
                 	System.out.println("PATH_3:::::"+"/home/hduser/data/LocalOptimalSolutions/"+key.toString()+".txt");
	            	DeleteFile(graphPath, fs);	//delete
	            	WriteEditPathToFile(tempEditPath,graphPath,fs); // write
					currentUpperBound = getUpperBound(tempEditPath);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		    	// if the folder ./data/tempLocalOptimalSolutions/G1-G2 is empty
		    	else if(folderStatus==null)
                {
                 	// read the localOptimalEditPath from the file G1-G2.txt
                   	graphPath = new Path("./data/LocalOptimalSolutions/"+key.toString()+".txt");
                   	System.out.println("PATH_4:::::"+"/home/hduser/data/LocalOptimalSolutions/"+key.toString()+".txt");
	            	if (fs.exists(graphPath)) 
	    			{
	            		System.out.println("read+1");
	    				BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(graphPath)));
	    				currentUpperBound = getUpperBound(br.readLine());	
	                }
	            	
                }
                ///////////////////////////////////////////////////////////////////////////////////
                for (Text val : values) {
    			
                	context.progress();

					parts = val.toString().split("\t");
					double costEditPath = Double.parseDouble(parts[5]); 
				
					if(currentUpperBound==-1)
					{
						currentUpperBound = Double.parseDouble(parts[6]);
					}
					
					if(costEditPath < currentUpperBound)
					{
						String editPath = parts[0]+"\t"+parts[1]+"\t"+parts[2]+"\t"+parts[3]+"\t"+parts[4]+"\t"+currentUpperBound; 
						context.write(new Text(editPath), new Text(""));
					}
					
		        }
		    
			
				
			}
	
		    
		}

		private void SearchAndSaveOptimalSolution() throws IOException {
			// TODO Auto-generated method stub
		
			// if the directory ./data/tempLocalOptimalSolutions is not empty
			if( folderStatus!= null )
		    {
				/* Choosing an optimal solution for each folder inside the directory 
				 * ./data/tempLocalOptimalSolutions
				*/
				
	            for (int i=0;i<folderStatus.length;i++)
	            {
	            	
	             	FileStatus[] fileStatus = fs.listStatus(folderStatus[i].getPath()); 
	             	tempEditPath = ""+folderStatus[i].getPath();	
	             	//System.out.println("toString:   "+path);
	             	String[] graphs = tempEditPath.split("/"); 
	             	tempEditPath = SearchMinimumEditPath(fileStatus,fs); //read: search the minimum silution of the folder listStatus
	            	graphPath = new Path("/home/hduser/data/LocalOptimalSolutions/"+graphs[7]+".txt");		            	
	            	System.out.println("PATH***/home/hduser/data/LocalOptimalSolutions/"+graphs[7]+".txt");
	            	// delete the previous file "graphPath"
	            	DeleteFile(graphPath, fs); //delete
	            	// create a new one with the new localEditPath
	            	WriteEditPathToFile(tempEditPath,graphPath,fs); //write
			    }
	            
	            DeleteFile(tempLocalOptimalPaths, fs);
	          
		    }

			
		}

//////////////////////////////////////////////////////////////////////////////////////////////////////
		
		private double getUpperBound(String tempEditPath) {
			// TODO Auto-generated method stub
			String[] parts;
			parts = tempEditPath.split("\t");
			Double upperBound = Double.parseDouble(parts[4]);
			return upperBound;
		}

//////////////////////////////////////////////////////////////////////////////////////////////////////
		
		private void WriteEditPathToFile(String tempEditPath, Path graphPath,FileSystem fs) throws IOException {
			// TODO Auto-generated method stub
			FSDataOutputStream out;
			out = fs.create(graphPath);
			System.out.println("write+1");
			out.writeBytes(tempEditPath);
			out.writeBytes("\n");
			out.close();	

		}
//////////////////////////////////////////////////////////////////////////////////////////////////////
		
		private void DeleteFile(Path graphPath, FileSystem fs) throws IOException {
			// TODO Auto-generated method stub
			System.out.println("delete+1");
			if (fs.exists(graphPath)) 
			{
				fs.delete(graphPath, true);
			}
		}
		
//////////////////////////////////////////////////////////////////////////////////////////////////////
		
		private String SearchMinimumEditPath(FileStatus[] fileStatus, FileSystem fs) throws IOException {
			// TODO Auto-generated method stub
			String tempEditPath = "";
			double minValue = Double.MAX_VALUE;
			String[] parts;
			for (int j=0;j<fileStatus.length;j++)
         	{
         		System.out.println("read+1");
                BufferedReader br=new BufferedReader(new InputStreamReader(fs.open(fileStatus[j].getPath())));
                String line;                
                // each bufferdReader has only one line....
                line=br.readLine();
            	parts= line.split("\t"); 
				//Choosing the minimal distance
				minValue = Math.min(minValue, Double.parseDouble(parts[4]));
				if(minValue==Double.parseDouble(parts[4]))
				{
					tempEditPath= line;
				}                        
         	}
			
			return tempEditPath;
		}
		
	}

	
	@Override
	public int run(String[] args) throws Exception {
	/*	Job job = getJobConf(args);

		FileInputFormat.addInputPath(job, new Path(args[0]));// specify the input path to be the first command-line argument passed by the user
		FileOutputFormat.setOutputPath(job, new Path(args[1]));// specify the output path to be the second command-line argument passed by the user
		return job.waitForCompletion(true) ? 0 : 1;// wait for the job to complete
		*/


		    Configuration conf = new Configuration();
	        conf.set("mapred.jar","/usr/local/hadoop-1.0.4/project.jar");
	        
	        conf.set("mapred.map.child.java.opts", "-Xmx1500M"); // 1500 MB per map
	        conf.setInt("mapred.tasktracker.map.tasks.maximum", 1);
	        conf.setInt("mapred.tasktracker.reduce.tasks.maximum", 1);
	        
	        if(args[2].equals("line")==true)
	        {
	        	conf.setInt("mapreduce.input.lineinputformat.linespermap", 1); 
	        }
	        conf.setInt("mapred.cluster.max.reduce.memory.mb", -1);
            conf.setInt("mapred.cluster.max.map.memory.mb", -1);
	        
 
            
	        conf.setBoolean("mapred.map.tasks.speculative.execution", false);
	        conf.setBoolean("mapred.reduce.tasks.speculative.execution", false);
	        conf.setBoolean("mapred.compress.map.output", true);
	        
	        Job job = new Job(conf, "HadoopPartialSearchTree");
	        //job.setJarByClass(algorithms.TestClass.class);
	     //   System.out.println("JAR"+job.getJar());
	        job.setMapperClass(PathCostMapper.class);
	        
	     // first iteration of HadoopPartialSearchTree (one line per map)
	        if(args[2].equals("line")==true)
	        {
	        	
	        	System.out.println("LINE.............................");
	        	job.setInputFormatClass(NLineInputFormat.class);
	        }
	        
	        job.setReducerClass(PathCostReducer.class);
	        job.setOutputKeyClass(Text.class);
	        job.setOutputValueClass(Text.class);
	   
	        FileInputFormat.addInputPath(job, new Path(args[0]));// specify the input path to be the first command-line argument passed by the user
	        FileOutputFormat.setOutputPath(job, new Path(args[1]));// specify the output path to be the second command-line argument passed by the user
	       // System.exit(job.waitForCompletion(true) ? 0 : 1);
	        return job.waitForCompletion(true) ? 0 : 1;// wait for the job to complete
		
	}
	
	public static void main(String[] args) throws Exception{
		// TODO Auto-generated method stub
		

		int res = ToolRunner.run(new Configuration(), new HadoopPartialSearchTree(), args);
		System.exit(res);

	}

}
