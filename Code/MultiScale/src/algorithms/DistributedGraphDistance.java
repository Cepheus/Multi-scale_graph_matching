package algorithms;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.StringTokenizer;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.Reducer.Context;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.NLineInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.ToolRunner;



import util.CoilCostFunction;
import util.Edge;
import util.EditPath;
import util.ExampleBaseJob;
import util.Graph;
import util.ICostFunction;
import util.LetterCostFunction;
import util.MoleculesCostFunction;
import util.MutagenCostFunction;
import util.Node;
import util.UniversalCostFunction;
import util.UniversalEdgeHandler;
import util.ExampleBaseJob;
import util.WebCostFunction;
import xml.XMLParser;



	/**
	 * @author Zeina Abu-Aisheh
	 * 
	 * @param args
	 * 
	 * HadoopPathsCostCalculations is a  class that performs calculations in Hadoop, 
	 * it searches for an optimal solution starting from some generated edit paths (i.e. editPaths that were generated by PartialSearchTree)
	 * 
	 * The type parameters are the type of the input key, the type of the input
	 * values, the type of the output key and the type of the output values
	 * 
	 **/

public class DistributedGraphDistance extends ExampleBaseJob{



	 
		/**
		* Mapper class
		* 
		* Input format :trainingGraphId-testGraphId<tab>editPath.toString() 
		* Output format :trainingGraphId-testGraphId<tab> branchOptimalCost
		* 
		* 
		**/

	
		public static class PathCostMapper extends
		Mapper<LongWritable, Text, Text, Text> {

			@Override
			/**
			* Mapper class
			* @param key: file's line number 
			* @param Value <trainingGraphFileId-trainingGraphId<tab>toString(editPath)>
			* @param Context is used to emit <key,value> where key = trainingGraphId-testGraphId and value=optimalCost of the branch
			**/
			public void map(LongWritable key, Text value, Context context)
					throws IOException, InterruptedException {

				

				boolean debug=false;
				double optimalCost=Double.MAX_VALUE;
				int methodNumber =0;
				String path = "";
				

			
				
				int dataSetNumber = 0;
				
				/*
				 * methodNumber is a variable
				 * 
				 * MethodNumber = 1 (plain-GED)
				 * MethodNumber = 2 (Heuristic GED)
				 * MethodNumber = 3 (BeamSearch)
				 * MethodNumber = 4 (Munkres's algorithm)
				 * MethodNumber = 5 (Distributed GED)
				 */
				
				String testGraphFileName="";
			    String trainingGraphFileName=""; // training's file name.
				Graph testGraph = null; //  test graph
				Graph trainingGraph = null; // training graph
				String trainingGraphClass=""; //training graph's class
				String testGraphClass=""; //test graph's class


				//System.out.println("TEST PATH ::::"+testGraphPath);
				String trainingGraphPath; // path of training graphs
				String testGraphPath; // path of test grapn);
				
    			StringTokenizer itr = new StringTokenizer(value.toString());
    			
    			//dataSetNumber = Integer.parseInt(itr.nextToken());

    			double alpha=-1;
    			double edgeCosts=-1;
    			double nodeCosts=-1;
    			
    			// 1st token (dataSetNumber)
                dataSetNumber = Integer.parseInt(itr.nextToken());
                
				Configuration conf = context.getConfiguration();
				// 2nd token (MethodNumber)
				if(conf.get("methodNumber").equals("readFromFile")==true)
				{
				
					methodNumber = Integer.parseInt(itr.nextToken());
					System.out.println("MethodNumber .. readFromFile.."+methodNumber);
	       
				}
				else
				{
	                
					methodNumber = Integer.parseInt(conf.get("methodNumber"));
	          //      System.out.println("@@@@@@@@@@@@HERE WE ARE ......"+methodNumber);

				}

    			
				if(dataSetNumber ==1)
				{
					// Letter-MED
					nodeCosts=0.7;
					edgeCosts=1.9;
					alpha=0.75;
					
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

					path="/usr/local/IAM/Letter/MED/";
				}
				else if( dataSetNumber == 2)
				{
					// Letter-LOW
					
					nodeCosts=0.3;
					edgeCosts=0.1;
					alpha=0.3;
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					path="/usr/local/IAM/Letter/LOW/";
				}
				else if( dataSetNumber == 3)
				{
					// Letter-HIGH
					nodeCosts=0.9;
					edgeCosts=1.7;
					alpha=0.75;
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					path="/usr/local/IAM/Letter/HIGH/";	
					
				}
				else if( dataSetNumber == 4)
				{
					//GREC-CostFunction
					nodeCosts=90;
					edgeCosts=15;
					alpha=0.50;
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					path="/usr/local/IAM/GREC/";
				}
				else if(dataSetNumber == 5)
				{
					
					nodeCosts=2.0;
					edgeCosts=2.0;
					alpha=0.50;
					Constants.costFunction = new CoilCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					path="/usr/local/IAM/COIL-DEL/";
				}
				else if(dataSetNumber == 6)
				{
					nodeCosts=2.0;
					edgeCosts=2.0;
					alpha=0.50;
					Constants.costFunction = new CoilCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					path="/usr/local/IAM/COIL-RAG/";
				}
				else if (dataSetNumber == 7) 
				{
					// AIDS
					//MoleculesCostFunction
					// 
					nodeCosts=1.1;
					edgeCosts=0.1;
					alpha=0.25;
					
					Constants.costFunction = new MoleculesCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

					path="/usr/local/IAM/AIDS/";
					
				}
				else if (dataSetNumber == 8) 
				{
					// FingerPrint
					nodeCosts=0.7;
					edgeCosts=0.5;
					alpha=0.75;
					
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

					path="/usr/local/IAM/Fingerprint/";
					
				}
				else if (dataSetNumber == 9) 
				{
					//MutagenCostFunction
					// Letter-MED
					nodeCosts=0.11;
					edgeCosts=1.1;
					alpha=0.25;
					
					Constants.costFunction = new MutagenCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 

					path="/usr/local/IAM/Mutagenicity/";
					
				}
				else if(dataSetNumber == 10)
				{
					
					Constants.costFunction = new WebCostFunction();
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					path = "/usr/local/IAM/Web/";

				}
				else if (dataSetNumber == 11 || dataSetNumber ==12 || dataSetNumber == 13 || dataSetNumber ==14 || dataSetNumber == 15 || dataSetNumber == 16 || dataSetNumber == 17 || dataSetNumber == 18 || dataSetNumber == 19 || dataSetNumber == 20 || dataSetNumber == 21) 
				{
					//WebCostFunction
					nodeCosts=1;
					edgeCosts=1;
					alpha=1;
					
					Constants.costFunction = new LetterCostFunction(nodeCosts,edgeCosts,alpha);
					Constants.edgeHandler = new UniversalEdgeHandler(); 
					if(dataSetNumber ==11)
					{
						path = "/usr/local/SyntheticGraphs/SG-5/";
					
					}
					else if (dataSetNumber == 12) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-10/";
						
					}
					else if (dataSetNumber == 13) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-15/";
						
					}
					else if (dataSetNumber == 14) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-20/";
						
					}
					else if (dataSetNumber == 15) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-25/";
						
					}
					else if (dataSetNumber == 16) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-30/";
						
					}
					else if (dataSetNumber == 17) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-35/";
						
					}
					else if (dataSetNumber == 18) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-40/";
						
					}
					else if (dataSetNumber == 19) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-45/";
						
					}
					else if (dataSetNumber == 20) 
					{
						//WebCostFunction
						path = "/usr/local/SyntheticGraphs/SG-50/";
						
					}
				}
				else 
				{
				
				}
				
	
                if (debug==true)System.out.println("METHOD NUMBER ====="+methodNumber);
    			
                if(methodNumber==1 ||methodNumber==2 || methodNumber==3 || methodNumber ==4 || methodNumber ==6)
                {
                	        			
    				
    				XMLParser xmlParser = new XMLParser();
        			while (itr.hasMoreTokens()) {

        				// getting testGraphFileName
        				testGraphFileName = itr.nextToken();
        				if (debug==true) System.out.println("***********testGraphFileName"+testGraphFileName);
        				
        				testGraphPath=path+testGraphFileName;
        				
        				// getting trainingGraphFileName	
        				trainingGraphFileName = itr.nextToken();
        				trainingGraphPath = path+trainingGraphFileName;
        				if (debug==true) System.out.println("***********trainingGraphFileName"+trainingGraphFileName);
        				
        				
        				try {
        					//parsing the training graph and the test graph
        					testGraph = xmlParser.parseGXL(testGraphPath);
        					trainingGraph= xmlParser.parseGXL(trainingGraphPath);
        					} 
        				catch (Exception e) {
        					// TODO Auto-generated catch block
        					e.printStackTrace();
        				}
        				//getting the class of the trainingGraph
        				
        				trainingGraphClass = itr.nextToken();
        				if (debug==true) System.out.println("*****************trainingGraphClass "+trainingGraphClass);
        				
        				testGraphClass = itr.nextToken();

        				if (debug==true) System.out.println("*****************testGraphClass "+testGraphClass);
        				
        			}
                	
                	if(methodNumber == 1){
    					
                		GraphEditDistance GED = new GraphEditDistance(testGraph,trainingGraph,Constants.costFunction,Constants.edgeHandler,debug);
   					 	optimalCost = GED.getBestEditpath().getTotalCosts();
   					 	if(debug==true) System.out.println("Distance between "+testGraphFileName+"and "+trainingGraphFileName+" = "+optimalCost);
                	}
                	else if(methodNumber == 2)
                	{
                		HeuristicGraphEditDistance GEDH = new HeuristicGraphEditDistance(testGraph,trainingGraph,Constants.costFunction,Constants.edgeHandler ,debug);
                		optimalCost = GEDH.getBestEditpath().getTotalCosts()+GEDH.getBestEditpath().getHeuristicCosts();
   					 	if(debug==true) System.out.println("Distance between "+testGraphFileName+"and "+trainingGraphFileName+" = "+optimalCost);
                	}

                	else if(methodNumber == 3)
                	{
                		BeamSearchGraphEditDistance GEDB = new BeamSearchGraphEditDistance(testGraph,trainingGraph,2, Constants.costFunction, Constants.edgeHandler ,debug);
                		optimalCost = GEDB.getBestEditpath().getTotalCosts();
                		if(debug==true) System.out.println("Distance between "+testGraphFileName+"and "+trainingGraphFileName+" = "+optimalCost);
                	}
                	else if(methodNumber== 4)
                	{
                		MatrixGenerator mgen = new MatrixGenerator();
                		Munkres munkres = new Munkres();
                		MunkresRec munkresRec = new MunkresRec();
                		mgen.setMunkres(munkresRec);
                		double[][] matrix;
                		matrix = mgen.getMatrix(testGraph, trainingGraph);
                		munkres.setGraphs(testGraph, trainingGraph);
                		optimalCost = munkres.getCosts(matrix);
                		if(debug==true) System.out.println("Distance between "+testGraphFileName+"and "+trainingGraphFileName+" = "+optimalCost);
                	}
                	else if(methodNumber==6)
                	{
                		System.out.println("MemoryControlled.............");
                		int satMemory = 20;
                		int kEditPaths = 5;
                		int nIterations = 50;
                		MemoryControlledGED mf = new MemoryControlledGED(testGraph, trainingGraph, satMemory, kEditPaths ,nIterations,Constants.costFunction, Constants.edgeHandler, debug);
                		optimalCost = mf.pmin.getTotalCosts();
                		if(debug==true) System.out.println("Distance between "+testGraphFileName+"and "+trainingGraphFileName+" = "+optimalCost);
                	}
                		

    				
                }
                
                else if(methodNumber == 5)
				{
                	
                	//*************************************************************************************************************************************************
                	// 3rd token (testGraphClass)
                    testGraphClass = itr.nextToken();
    				if(debug==true)System.out.println("testGraphClass-----------"+testGraphClass);
    				// 4th token (testGraphClass)
    				trainingGraphClass = itr.nextToken();
    				if(debug==true)System.out.println("trainingGraphClass-----------"+trainingGraphClass);
    				
    				String editPathString =""; // to get the edit path string

    				//Constants.costFunction = (ICostFunction)new UniversalCostFunction(0.5); 
    				context.progress();
    				
    				//5th token (optimalSolution)
    				optimalCost = Double.parseDouble(itr.nextToken());
    				//6th token (source-ID)
    				testGraphFileName= itr.nextToken();
    				//7th token (training-ID)
    				trainingGraphFileName= itr.nextToken();
    			
                	//**********************************************************************************************************************************************
                	
				}
				
				context.write(new Text(testGraphFileName), new Text(""+testGraphClass+"<>"+trainingGraphClass+"<>"+optimalCost+"<>"+trainingGraphFileName));
			}
		}

	/**
	* Reducer class
	* 
	* Input format :<testGraphFilePath, trainingGraphFileName-trainingGraphClass-distanceGED(testGraph,trainingGraph> 
	* Output format :<testGraphFilePath: recommended class>
	* 
	* 
	**/
		public static class PathCostReducer extends
			Reducer<Text, Text, Text, Text> {
		
		@Override
		/**
		 * @param key = <sourceTargetIDS>
		 * @param value=<OptimalCost>
		 * **/
		
		public void reduce(Text key, Iterable<Text> values, Context context
		
		) throws IOException, InterruptedException {

			/*
			double minValue = Double.MAX_VALUE; // A variable that is used for choosing the nearest neighbor of the test graph

			
			for (Text val : values) {
				String optimalCost = val.toString();
				
				//Choosing the minimal distance
				minValue = Math.min(minValue, Double.parseDouble(optimalCost));
				*/
			/*	if(minValue==Double.parseDouble(optimalCost))
				{
					System.out.println("*******"+minValue);	
				}
			*/
			
			
			/*
			*key = <testGraphFilePath>
			*value=<trainingGraphFileName-trainingGraphClass-distanceGED(testGraph,trainingGraph)>
			*/

			int MegaBytes = 1048576;
			long javaMaxMemory = Runtime.getRuntime().maxMemory() / MegaBytes;
			//System.out.println("MAX MEMORY  "+javaMaxMemory);
			
			String testClass ="";
			String trainingClass ="";
			String trainingGraphName = "";
			
	//		System.out.println("******FILE: "+key.toString());
			double minValue = Double.MAX_VALUE; // A variable that is used for choosing the nearest neighbor of the test graph
			int counter = 0; // to see whether a test graph is well classified or not
			String[] parts;
			
			for (Text val : values) {
				context.progress();
				String info = val.toString();
		//		System.out.println("info"+info);
				/*
				 * splitting the val variable to take the information inside
				 *  parts[0]: Graph's Class
				 *  parts[1]: Heuristic GED
				 */
				parts= info.split("<>"); 
				//System.out.println("the length is::::::"+parts.length);
				//System.out.println("distance ...."+parts[2]);
				System.out.println("****" + Double.parseDouble(parts[2]));
				//Choosing the minimal distance
				minValue = Math.min(minValue, Double.parseDouble(parts[2]));

				if(minValue==Double.parseDouble(parts[2]))
				{
					testClass =  parts[0];
					trainingClass = parts[1];
					trainingGraphName = parts[3];
				}
			
			}
			
			if(testClass.equals(trainingClass))
		 	{
		 		counter++;
		 	}
			System.out.println("Min Value = "+minValue + " , targetClass ="+testClass+ " and trainingClass =  "+trainingClass );

		    //Emitting <key,value> = <testGraphFilePath: recommended class>
			context.write(key, new Text(trainingGraphName+"	"+testClass+"	"+counter+" "+minValue));
			
			
		}
		
			
		}
		
		

	///////////////////////////////////////////////////////////////////////////////////////////////////


	
	@Override
	public int run(String[] args) throws Exception {
	/*	Job job = getJobConf(args);

		FileInputFormat.addInputPath(job, new Path(args[0]));// specify the input path to be the first command-line argument passed by the user
		FileOutputFormat.setOutputPath(job, new Path(args[1]));// specify the output path to be the second command-line argument passed by the user
		return job.waitForCompletion(true) ? 0 : 1;// wait for the job to complete
		*/


		    Configuration conf = new Configuration();
		    if(args.length==3)
		    {
		    	conf.set("methodNumber", args[2]);
		    }
		    else{
		    	conf.set("methodNumber", "readFromFile");
		    }
		   
	        conf.set("mapred.jar","/usr/local/hadoop-1.0.4/project.jar");
	       
	        conf.set("mapred.map.child.java.opts", "-Xmx1500M");

            conf.setInt("mapred.tasktracker.map.tasks.maximum", 1);
            conf.setInt("mapred.tasktracker.reduce.tasks.maximum", 1);
	        
            conf.setInt("mapred.cluster.max.reduce.memory.mb", -1);
            conf.setInt("mapred.cluster.max.map.memory.mb", -1);
	        
           // conf.setInt("mapreduce.input.lineinputformat.linespermap", 1); 
            
	        conf.setBoolean("mapred.map.tasks.speculative.execution", false);
	        conf.setBoolean("mapred.reduce.tasks.speculative.execution", false);
	        conf.setBoolean("mapred.compress.map.output", true);
	       
	        Job job = new Job(conf, "DistributedGraphDistance");
	        job.setNumReduceTasks(1);
	        //job.setJarByClass(algorithms.TestClass.class);
	        System.out.println("JAR"+job.getJar());
	    	final int MegaBytes = 1048576;
	        
	    	long javaTotalMemory = Runtime.getRuntime().totalMemory()/MegaBytes;
			long javaFreeMemory = Runtime.getRuntime().freeMemory() / MegaBytes;
			long mem =  (javaTotalMemory - javaFreeMemory);
			
	        System.out.println("mem::::"+mem);
	        
	        job.setMapperClass(PathCostMapper.class);
	       // job.setInputFormatClass(NLineInputFormat.class);
	        
	        System.out.print("------------------"+job.getMapperClass());
	        job.setReducerClass(PathCostReducer.class);
	        job.setOutputKeyClass(Text.class);
	        job.setOutputValueClass(Text.class);
	        FileInputFormat.addInputPath(job, new Path(args[0]));// specify the input path to be the first command-line argument passed by the user
	        FileOutputFormat.setOutputPath(job, new Path(args[1]));// specify the output path to be the second command-line argument passed by the user
	       // System.exit(job.waitForCompletion(true) ? 0 : 1);
	        return job.waitForCompletion(true) ? 0 : 1;// wait for the job to complete
		
	}
	
	public static void main(String[] args) throws Exception{
		// TODO Auto-generated method stub
		
		File file = new File("/usr/local/hadoop-1.0.4/data/GraphDistance/"+args[2]+".txt");
		PrintStream ps = new PrintStream(file);
		final double start; // starting time
		final double end; // ending time
		start =System.currentTimeMillis();
		int res = ToolRunner.run(new Configuration(), new DistributedGraphDistance(), args);
		end =System.currentTimeMillis();
		System.out.println("FINISHED :::: TIME TAKEN TO CLASSIFY GRAPHS :: "+(end-start));
		ps.println(end-start);
		ps.close();

		System.exit(res);

	}

}
